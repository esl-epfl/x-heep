# Run on FPGA

This project offers X-HEEP implementetions on Xilinx FPGAs.

## Set-up

In this version, the X-HEEP architecture is implemented on the programmable logic (PL) side of the FPGA, and its input/output are connected to the available headers on the FPGA board.

1. Make sure you have the FPGA board files installed in your Vivado.
> For example, for the Pynq-Z2 board, use the documentation provided at the following [link](https://pynq.readthedocs.io/en/v2.5/overlay_design_methodology/board_settings.html) to download and install them.

2. Make sure you set up the Vivado environments by running
   ```
   source <vivado-installation-path>/settings64.sh
   ```
   > We recommend adding this command to your `.bashrc`

3. Install the Xilinx cable drivers.
* Follow the [instructions for Linux](https://docs.amd.com/api/khub/documents/6EIhov6ruoilhq8zq7bXBA/content?Ft-Calling-App=ft%2Fturnkey-portal&Ft-Calling-App-Version=4.3.26#G4.262534)
* Restart your PC

## Building and programming the FPGA

To build and program the bitstream for your FPGA with vivado, make sure you have run `mcu-gen` and then run:

```
make vivado-fpga FPGA_BOARD=<BOARD_NAME>
```

where `<BOARD_NAME>` can be `pynq-z2`, `nexys-a7-100t`, `zcu104` or `zcu102`. From now on we will refer to it as `<BOARD_NAME>`.

Adding the fusesoc flag `use_bscane_xilinx` enables the native Xilinx scanchain for the JTAG interface in the on chip debug module (Currently only supported for the `pynq-z2` board):

```
make vivado-fpga FPGA_BOARD=pynq-z2 FUSESOC_FLAGS=--flag=use_bscane_xilinx
```

To program the bitstream, open Vivado,

```
open --> Hardware Manager --> Open Target --> Autoconnect --> Program Device
```

and choose the file `openhwgroup.org_systems_core-v-mini-mcu_0.bit` in the `build/openhwgroup.org_systems_core-v-mini-mcu_0/<BOARD_NAME>-vivado`.

Or simply type:

```
make vivado-fpga-pgm FPGA_BOARD=<BOARD_NAME>
```

## Running firmware on the FPGA

To run SW, follow the [Debug](./Debug.md) guide to load the binaries with the HS2 cable over JTAG,
or follow the [ExecuteFromFlash](./ExecuteFromFlash.md) guide if you have a FLASH attached to the FPGA.

Do not forget that the `pynq-z2` board requires you to have the ethernet cable attached to the board while running.

For example, if you want to run your application using flash_exec, do as follow:
compile your application, e.g. `make app PROJECT=example_matfadd TARGET=pynq-z2 ARCH=rv32imfc LINKER=flash_exec`
and then follow the [ExecuteFromFlash](./ExecuteFromFlash.md) to program the flash and set the boot buttons on the FPGA correctly.
To look at the output of your printf, run in another terminal:
`picocom -b 9600 -r -l --imap lfcrlf /dev/ttyUSB2`
Please be sure to use the right `ttyUSB` number (you can discover it with `dmesg --time-format iso | grep FTDI` for example).

## How to get X-HEEP run firmware on the FPGA

To get X-HEEP running on the FPGA, you need to program the FPGA with the bitstream generated by the `make vivado-fpga` command. After that, you can run the software application on it.

On Xilinx FPGAs, the JTAG, UART, and SPI interfaces of X-HEEP are exposed on PMODs. Once that you have indentified the pinout of the PMODS you can connect to them your preferred JTAG connector, UART to USB converter, and SPI flash programmer.

To run the software application on the FPGA, you can use the HS2 cable to load the binaries over JTAG, or you can use the SPI flash programmer to program the flash and set the boot switches on the FPGA correctly.

Both the JTAG, UART and SPI interfaces are mapped to be compliant with the [ESL iceprog compatible programmer](https://github.com/esl-epfl/x-heep-programmer-pmod).

To interface with the jtag one can use [openocd](http://openocd.org/), to interface with the UART one can use [picocom](https://linux.die.net/man/8/picocom), and to interface with the SPI flash one can use iceprog (from the [icestorm](http://www.clifford.at/icestorm/) project) already shipped and built in X-HEEP main repo.

### JTAG programming

Onece that openocd is installed, depending on your setup, you can run one of the following commands to connect to the FPGA:

```
openocd -f ./tb/core-v-mini-mcu-esl-programmer.cfg
```

or

```
openocd -f ./tb/core-v-mini-mcu-nexys-hs2.cfg
```

or

```
openocd -f ./tb/core-v-mini-mcu-pynq-z2-bscan.cfg
```

or directly running one of the openocd recipes in the Makefile:

```
make openOCD_epflp
```

```
openOCD_bscan
```

Now you can run gdb in another shell and connect to the openocd server as explained in the [Debug](./Debug.md) guide.

### SPI Flash programming

If you have an SPI flash programmer, you can program the flash with the programmer and set the boot switches on the FPGA board correctly. X-HEEP will boot and copy the code to the on-chip memory or directly fetch instructions from the flash and run the application.

If you have access to the [ESL programmer](https://github.com/esl-epfl/x-heep-programmer-pmod) you can use the following command to program the flash:

```
make flash-prog
```

Check the self-documentig Makefile to see the available options and recipes.

## Useful info on FPGA deployments

X-HEEP interface is connected to the FPGA board through the following pins:

| Signal Name            | Description         | PYNQ-Z2 | Nexys-A7-100t | ZCU104 | ZCU102 |
|------------------------|---------------------|---------|---------------|--------|--------|
| `clk_i`                | Clock input         | H16     | E3            | --     | --     |
| `clk_300mhz_p`         | Clock input         | --      | --            | AH18   | --     |
| `clk_300mhz_n`         | Clock input         | --      | --            | AH17   | --     |
| `clk_125mhz_p`         | Clock input         | --      | --            | --     | AL8    |
| `clk_125mhz_n`         | Clock input         | --      | --            | --     | AL7    |
| `rst_i`                | Reset input         | L19     | C12           | M11    | AM13   |
| `rst_led_o`            | Reset output        | M14     | V11           | D5     | AG14   |  
| `clk_led_o`            | Clock output        | N16     | J13           | D6     | AF13   |
| `exit_valid_o`         | Exit valid          | R14     | N14           | A5     | AE13   |
| `exit_value_o`         | Exit value          | P14     | R18           | B5     | AJ14   |
| `execute_from_flash_i` | Execute from flash  | M19     | L16           | E4     | AN14   |
| `boot_select_i`        | Boot mode selection | M20     | M13           | D4     | AP14   |
| `spi_flash_csb_o`      | Flash CS            | U18     | C17           | L10    | F20    |
| `spi_flash_sck_o`      | Flash SCK           | Y18     | D18           | J9     | D20    |
| `spi_flash_sd_io[0]`   | Flash IO0           | U19     | E18           | M10    | G20    |
| `spi_flash_sd_io[1]`   | Flash IO1           | Y19     | G17           | K9     | E20    |
| `spi_flash_sd_io[2]`   | Flash IO2           | W18     | D17           | M8     | J20    |
| `spi_flash_sd_io[3]`   | Flash IO3           | Y16     | E17           | K8     | D22    |
| `uart_tx_o`            | UART TX             | W14     | C4            | G8     | A20    |
| `uart_rx_i`            | UART RX             | V16     | D4            | G6     | B21    |
| `jtag_tdi_i`           | JTAG TDI            | Y14     | F13           | H8     | B20    |
| `jtag_tdo_o`           | JTAG TDO            | V12     | G13           | J6     | C22    |
| `jtag_tms_i`           | JTAG TMS            | T11     | E16           | G7     | A22    |
| `jtag_tck_i`           | JTAg TCK            | W16     | H16           | H6     | C21    |
| `jtag_trst_ni`         | JTAg TRST           | W19     | J15           | M9     | J19    |
| `i2c_scl_io`           | I2C SCL             | W13     | V16           | J7     | D21    |
| `i2c_sda_io`           | I2C SDA             | T10     | T15           | H7     | A21    |
| `spi_csb_o`            | SPI CS              | F16     | K1            | H19    | AC2    |
| `spi_sck_o`            | SPI SCK             | H15     | F6            | G19    | AC1    |
| `spi_sd_io[0]`         | SPI IO0             | T12     | J2            | L15    | W5     |
| `spi_sd_io[1]`         | SPI IO1             | W15     | G6            | K15    | W4     |
| `spi_sd_io[2]`         | SPI IO2             | P18     | E7            | C13    | AC7    |
| `spi_sd_io[3]`         | SPI IO3             | N17     | J3            | C12    | AC6    |
| `gpio_io[0]`           | GPIO 0              | T14     | N17           | D11    | T11    |
| `gpio_io[1]`           | GPIO 1              | Y8      | M18           | D10    | U11    |
| `gpio_io[2]`           | GPIO 2              | W8      | P17           | A8     | U6     |
| `gpio_io[3]`           | GPIO 3              | Y7      | M17           | A7     | V6     |
| `gpio_io[4]`           | GPIO 4              | Y6      | P18           | H18    | T6     |
| `gpio_io[5]`           | GPIO 5              | U12     | U14           | H17    | T7     |
| `gpio_io[6]`           | GPIO 6              | W10     | T16           | K17    | K12    |
| `gpio_io[7]`           | GPIO 7              | V10     | V15           | J17    | L12    |
| `gpio_io[8]`           | GPIO 8              | V8      | V14           | H16    | N12    |
| `gpio_io[9]`           | GPIO 9              | U8      | V12           | G16    | P12    |
| `gpio_io[10]`          | GPIO 10             | V7      | H17           | G15    | K13    |
| `gpio_io[11]`          | GPIO 11             | U7      | T10           | F15    | L13    |
| `gpio_io[12]`          | GPIO 12             | V6      | R10           | F11    | Y9     |
| `gpio_io[13]`          | GPIO 13             | U13     | K16           | E10    | Y10    |
| `gpio_io[14]`          | GPIO 14             | V13     | K13           | B11    | AB5    |
| `gpio_io[15]`          | GPIO 15             | M15     | J17           | A11    | AB6    |
| `gpio_io[16]`          | GPIO 16             | G14     | J18           | B9     | U4     |
| `gpio_io[17]`          | GPIO 17             | L14     | T9            | B8     | U5     |
| `pdm2pcm_clk_io`       | PDM CLK             | Y9      | P15           | K19    | Y2     |
| `pdm2pcm_pdm_io`       | PDM PDM             | A20     | T11           | K18    | Y1     |
| `i2s_sck_io`           | I2S SCK             | B19     | L18           | E18    | V4     |
| `i2s_ws_io`            | I2S WS              | B20     | H15           | E17    | V3     |
| `i2s_sd_io`            | I2S SD              | P15     | U13           | G18    | W7     |
| `spi2_csb_o[0]`        | SPI2 CSB0           | W6      | J14           | F18    | V11    |
| `spi2_csb_o[1]`        | SPI2 CSB1           | T15     | P14           | D17    | V12    |
| `spi2_sck_o`           | SPI2 SCK            | C20     | T14           | C17    | V7     |
| `spi2_sd_io[0]`        | SPI2 IO0            | V17     | K2            | F12    | V8     |
| `spi2_sd_io[1]`        | SPI2 IO1            | V18     | V17           | E12    | U8     |
| `spi2_sd_io[2]`        | SPI2 IO2            | T16     | U17           | H13    | U9     |
| `spi2_sd_io[3]`        | SPI2 IO3            | R17     | U16           | H12    | L11    |



## FPGA Utilizations

X-HEEP is a continuosly evolving design, therefore these numbers need to be updated from time to time.

As of today (`29.01.2025`), on a `pynq-z2` FPGA, X-HEEP utilizes:

### Small configuration


It contains few peripherals, 64kB of SRAM, the small bus, and the CV32E2 CPU with RV32IMC ISA extensions.

Generated as:

```
make mcu-gen MCU_CFG_PERIPHERALS=mcu_cfg_minimal.hjson
make vivado-fpga FPGA_BOARD=pynq-z2
```

| Resource         | Quantity        | Utilization (%) |
|------------------|-----------------|-----------------|
| Slice LUTs       | 12.1K           | 22.7            |
| Slice Registers  | 12.1K           | 11.3            |
| RAM              | 16              | 11.4            |
| DSP              | 1               | 0.5             |


### Bigger configuration


It contains more peripherals, 64kB of SRAM, the wider bus, and the CV32E40P CPU with RV32IMFCXpulp ISA extensions.

Generated as:

```
make mcu-gen CPU=cv32e40p BUS=NtoM
make vivado-fpga FPGA_BOARD=pynq-z2 FUSESOC_PARAM="--COREV_PULP=1 --FPU=1"
```

| Resource         | Quantity        | Utilization (%) |
|------------------|-----------------|-----------------|
| Slice LUTs       | 33.5K           | 62.9            |
| Slice Registers  | 28.8K           | 27.1            |
| RAM              | 16              | 11.4            |
| DSP              | 9               | 4.1             |

