#!/usr/bin/env python

import sys
import random

# Copyright 2017 ETH Zurich and University of Bologna.
# Copyright and related rights are licensed under the Solderpad Hardware
# License, Version 0.51 (the License); you may not use this file except in
# compliance with the License.  You may obtain a copy of the License at
# http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
# or agreed to in writing, software, hardware and materials distributed under
# this License is distributed on an AS IS BASIS, WITHOUT WARRANTIES OR
# CONDITIONS OF ANY KIND, either express or implied. See the License for the
# specific language governing permissions and limitations under the License.

def write_arr(f, name, arr, ctype, size):
    f.write("const " + ctype + " " + name + "[] = {\n")
    i = 1
    for v in arr:
        if i % size == 0:
            f.write('%d,\n' % (v))
        else:
            f.write('%d,' % (v))
        i+=1
    f.write('};\n\n')
    return


################################################################################
f = open('matrixMul8.h', 'w')
f.write('#ifndef _MATMUL8_\n')
f.write('#define _MATMUL8_\n')
f.write('// This file is automatically generated\n')


SIZE = 16
RANGE = 4

m_a   = []
m_b   = []
m_exp = []

for i in range(0,SIZE):
    for j in range(0,SIZE):
        a = random.randint(-RANGE, RANGE-1)
        b = random.randint(-RANGE, RANGE-1)

        m_a.append(a)
        m_b.append(b)

for i in range(0,SIZE):
    for j in range(0,SIZE):
        r = 0

        for k in range (0,SIZE):
            r = r + m_a[i * SIZE + k] * m_b[k * SIZE + j]

        m_exp.append(r)


write_arr(f, 'm_a',   m_a, 'int8_t', SIZE)
write_arr(f, 'm_b_transposed',   m_b, 'int8_t', SIZE)
write_arr(f, 'm_exp', m_exp, 'int32_t', SIZE)

f.write('#define SIZE %d\n' % SIZE)


f.write('#endif')
