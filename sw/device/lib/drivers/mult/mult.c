/*
                              *******************
******************************* C SOURCE FILE *******************************
**                            *******************                          **
**                                                                         **
** project  : x-heep                                                       **
** filename : mult.c                                                       **
** date     : 23/08/2025                                                   **
**                                                                         **
*****************************************************************************
**                                                                         **
** Minimal HAL for the MULT peripheral (memory-mapped multiplier).         **
** Registers (32-bit):                                                     **
**   A        (rw)  - Operand A                                            **
**   B        (rw)  - Operand B                                            **
**   PRODUCT  (ro)  - A * B (low 32 bits)                                  **
**                                                                         **
*****************************************************************************
*/

#include "mult.h"   // mult_t, prototypes
#include "mult_regs.h"      // autogenerated: *_REG_OFFSET
#include "mmio.h"
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

/* -------------------------------------------------------------------------- */
/*                            EXPORTED FUNCTIONS                               */
/* -------------------------------------------------------------------------- */

__attribute__((weak, optimize("O0"))) void handler_irq_mult(uint32_t id) {
  // No interrupt line is used for MULT in the base assignment.
  // Provide a weak symbol so users can override if they later add an IRQ.
  (void)id;
}

/**
 * Initialize the MULT device handle with a base address.
 * You can skip this if you construct mult_t directly.
 */
void mult_init(mult_t *dev, uintptr_t base_addr) {
  dev->base_addr = mmio_region_from_addr(base_addr);
}

/** Write Operand A (32-bit). */
void mult_set_a(const mult_t *dev, uint32_t a) {
  mmio_region_write32(dev->base_addr, MULT_A_REG_OFFSET, a);
}

/** Write Operand B (32-bit). */
void mult_set_b(const mult_t *dev, uint32_t b) {
  mmio_region_write32(dev->base_addr, MULT_B_REG_OFFSET, b);
}

/** Convenience: write both operands. */
void mult_write_operands(const mult_t *dev, uint32_t a, uint32_t b) {
  mult_set_a(dev, a);
  mult_set_b(dev, b);
}

/** Read PRODUCT (low 32 bits). */
uint32_t mult_get_product(const mult_t *dev) {
  return mmio_region_read32(dev->base_addr, MULT_PRODUCT_REG_OFFSET);
}

/**
 * Convenience: perform A*B by writing operands and immediately reading PRODUCT.
 * For the simple combinational design, this returns the correct value in the
 * same call; if you later pipeline the HW, you might poll or add a status bit.
 */
uint32_t mult_mul_blocking(const mult_t *dev, uint32_t a, uint32_t b) {
  mult_write_operands(dev, a, b);
  return mult_get_product(dev);
}

/**
 * Optional tiny self-test: checks a couple of vectors.
 * Returns true on success.
 */
bool mult_selftest(const mult_t *dev) {
  struct {
    uint32_t a, b, expect;
  } vecs[] = {
      {0u, 0u, 0u},
      {1u, 1u, 1u},
      {7u, 9u, 63u},
      {0xFFFFu, 2u, 0x1FFFEu},
  };

  for (size_t i = 0; i < sizeof(vecs) / sizeof(vecs[0]); ++i) {
    uint32_t got = mult_mul_blocking(dev, vecs[i].a, vecs[i].b);
    if (got != vecs[i].expect) return false;
  }
  return true;
}
