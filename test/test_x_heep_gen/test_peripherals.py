import sys
import pathlib

# Mix of stack overflow comments, it adds "x-heep/util" to the python path (to import mcu_gen, and also x_heep_gen (needed by mcu_gen))
directory = pathlib.Path(__file__).resolve().parent.parent.parent
sys.path.append(str(directory.joinpath("util")))

import mcu_gen
import os
import hjson


x_heep_cfg = "configs/general.hjson"
pad_cfg = "pad_cfg.hjson"
config_directory = "test/test_x_heep_gen/configs/"
existing_extensions = [".hjson", ".py"]
output_directory = "test/test_x_heep_gen/outputs"
template = "test/test_x_heep_gen/template.hjson.tpl"


def output_filename(example, extension):
    """
    Generate the output filename for the given example and extension
    :param example: the example number to run
    :param extension: the extension of the configuration file
    :return: the output filename
    """
    return f"{output_directory}/example{example}-{extension[1:]}.hjson"


class PeripheralsDescription:
    """
    Contains all attributes concerning peripherals that are generated by mcu_gen
    """

    def __init__(self, example, extension):
        print(output_filename(example, extension))
        with open(output_filename(example, extension), "r") as file:
            content = hjson.load(file)

        self.ao_peripheral_start_address = content["ao_peripheral_start_address"]
        self.ao_peripheral_size_address = content["ao_peripheral_size_address"]

        # Standardize the ao_peripherals
        self.ao_peripherals = [p for p in content["ao_peripherals"]]
        self.ao_peripherals_count = content["ao_peripherals_count"]
        self.dma_ch_count = content["dma_ch_count"]
        self.dma_ch_size = content["dma_ch_size"]
        self.num_dma_master_ports = content["num_dma_master_ports"]
        self.num_dma_xbar_channels_per_master_port = content[
            "num_dma_xbar_channels_per_master_port"
        ]
        self.fifo_depth = content["fifo_depth"]
        self.addr_mode_en = content["addr_mode_en"]
        self.subaddr_mode_en = content["subaddr_mode_en"]
        self.hw_fifo_mode_en = content["hw_fifo_mode_en"]
        self.zero_padding_en = content["zero_padding_en"]
        self.dma_xbar_masters_array = content["dma_xbar_masters_array"]
        self.peripheral_start_address = content["peripheral_start_address"]
        self.peripheral_size_address = content["peripheral_size_address"]

        try:
            self.pdm2pcm_cic_only = content["pdm2pcm_cic_only"]
        except:
            self.pdm2pcm_cic_only = None

        # Standardize the peripherals
        added = 0
        filtered_peripherals = []
        # Reconstructs the peripherals list with the is_included field removed
        for name, info in content["peripherals"].items():
            if info.get("is_included") == "yes":
                peripheral_info = dict(info)
                peripheral_info["name"] = name
                del peripheral_info[
                    "offset"
                ]  # offset changes between configurations (hardcoded in hjson, computed in python), thus they wan't be the same
                del peripheral_info["is_included"]
                filtered_peripherals.append(peripheral_info)
                added += 1
        self.peripherals = filtered_peripherals
        self.peripherals_count = added

        self.extension = extension

    def __eq__(self, other):

        eq = True
        if self.ao_peripheral_start_address != other.ao_peripheral_start_address:
            eq = False
            print(
                f"ao_peripheral_start_address: {self.ao_peripheral_start_address} ({self.extension[1:]}) != {other.ao_peripheral_start_address} ({other.extension[1:]})"
            )
        if self.ao_peripheral_size_address != other.ao_peripheral_size_address:
            eq = False
            print(
                f"ao_peripheral_size_address: {self.ao_peripheral_size_address} ({self.extension[1:]}) != {other.ao_peripheral_size_address} ({other.extension[1:]})"
            )
        if len(self.ao_peripherals) != len(other.ao_peripherals):
            eq = False
            print(
                f"ao_peripherals length mismatch: {len(self.ao_peripherals)} ({self.extension[1:]}) != {len(other.ao_peripherals)} ({other.extension[1:]})"
            )
        else:
            for i, (self_p, other_p) in enumerate(
                zip(self.ao_peripherals, other.ao_peripherals)
            ):
                if self_p != other_p:
                    eq = False
                    print(
                        f"ao_peripheral {i}: {self_p} ({self.extension[1:]}) != {other_p} ({other.extension[1:]})"
                    )
        if self.ao_peripherals_count != other.ao_peripherals_count:
            eq = False
            print(
                f"ao_peripherals_count: {self.ao_peripherals_count} ({self.extension[1:]}) != {other.ao_peripherals_count} ({other.extension[1:]})"
            )
        if self.dma_ch_count != other.dma_ch_count:
            eq = False
            print(
                f"dma_ch_count: {self.dma_ch_count} ({self.extension[1:]}) != {other.dma_ch_count} ({other.extension[1:]})"
            )
        if self.dma_ch_size != other.dma_ch_size:
            eq = False
            print(
                f"dma_ch_size: {self.dma_ch_size} ({self.extension[1:]}) != {other.dma_ch_size} ({other.extension[1:]})"
            )
        if self.num_dma_master_ports != other.num_dma_master_ports:
            eq = False
            print(
                f"num_dma_master_ports: {self.num_dma_master_ports} ({self.extension[1:]}) != {other.num_dma_master_ports} ({other.extension[1:]})"
            )
        if (
            self.num_dma_xbar_channels_per_master_port
            != other.num_dma_xbar_channels_per_master_port
        ):
            eq = False
            print(
                f"num_dma_xbar_channels_per_master_port: {self.num_dma_xbar_channels_per_master_port} ({self.extension[1:]}) != {other.num_dma_xbar_channels_per_master_port} ({other.extension[1:]})"
            )
        if self.dma_xbar_masters_array != other.dma_xbar_masters_array:
            eq = False
            print(
                f"dma_xbar_masters_array: {self.dma_xbar_masters_array} ({self.extension[1:]}) != {other.dma_xbar_masters_array} ({other.extension[1:]})"
            )
        if self.peripheral_start_address != other.peripheral_start_address:
            eq = False
            print(
                f"peripheral_start_address: {self.peripheral_start_address} ({self.extension[1:]}) != {other.peripheral_start_address} ({other.extension[1:]})"
            )
        if self.peripheral_size_address != other.peripheral_size_address:
            eq = False
            print(
                f"peripheral_size_address: {self.peripheral_size_address} ({self.extension[1:]}) != {other.peripheral_size_address} ({other.extension[1:]})"
            )
        if len(self.peripherals) != len(other.peripherals):
            eq = False
            print(
                f"peripherals length mismatch: {len(self.peripherals)} ({self.extension[1:]}) != {len(other.peripherals)} ({other.extension[1:]})"
            )
        else:
            for i, (self_p, other_p) in enumerate(
                zip(self.peripherals, other.peripherals)
            ):
                if self_p != other_p:
                    eq = False
                    print(
                        f"peripheral {i}: {self_p} ({self.extension[1:]}) != {other_p} ({other.extension[1:]})"
                    )
        if self.peripherals_count != other.peripherals_count:
            eq = False
            print(
                f"peripherals_count: {self.peripherals_count} ({self.extension[1:]}) != {other.peripherals_count} ({other.extension[1:]})"
            )
        if self.pdm2pcm_cic_only != other.pdm2pcm_cic_only:
            eq = False
            print(
                f"pdm2pcm_cic_only: {self.pdm2pcm_cic_only} ({self.extension[1:]}) != {other.pdm2pcm_cic_only} ({other.extension[1:]})"
            )

        return eq


def run_test(example, example_name):
    """
    Compare the output of mcu_gen with an hjson config and a python config. Mcu_gen has to be called before running this script.
    :param example: the example number to run

    :return: True if the test passed, False otherwise
    """

    # Writes the output in a PeripheralsDescription object
    hjson_output = PeripheralsDescription(example, ".hjson")
    py_output = PeripheralsDescription(example, ".py")

    result = hjson_output == py_output

    if result:
        print(f'Test "{example_name}" passed')
    else:
        print(f'Test "{example_name}" failed')

    return result


def __generate_argv(
    example_number: int,
    config_dir: str,
    pads_cfg: str,
    output_dir: str,
    template: str,
    extension: str,
):
    return [
        "mcu_gen.py",
        "--config",
        f"{config_dir}/example{example_number}.{extension}",
        "--pads_cfg",
        pads_cfg,
        "--cfg_peripherals",
        f"{config_dir}/mcu_cfg{example_number}.hjson",
        "--outdir",
        output_dir,
        "--outfile",
        f"{output_dir}/example{example_number}-{extension}.hjson",
        "--tpl-sv",
        template,
    ]


def generate_examples(
    num_examples: int,
    config_dir: str,
    pads_cfg: str,
    output_dir: str,
    template: str,
):
    """
    Generate examples with both Python and HJSON configurations.

    :param num_examples: Number of tests to run
    :param config_dir: Directory containing example (test) configurations
    :param pads_cfg: Path to pads configuration file
    :param cfg_peripherals: Path to peripherals configuration file
    :param output_dir: Directory to store generated outputs
    :param template: Path to template file to drop mcu_gen.py outputs (kwargs)
    """

    # Reset the output directory
    output_path = pathlib.Path(output_dir)
    if output_path.exists():
        os.system(f"rm -rf {output_path}")
    output_path.mkdir(parents=True)

    # Store original sys.argv
    original_argv = sys.argv.copy()

    try:
        for i in range(1, num_examples + 1):
            print(f"Processing example {i}")

            # Generate with Python configuration
            print(f"Running Python configuration for example {i}")
            sys.argv = __generate_argv(
                example_number=i,
                config_dir=config_dir,
                pads_cfg=pads_cfg,
                output_dir=output_dir,
                template=template,
                extension="py",
            )
            mcu_gen.main()

            # Generate with HJSON configuration
            print(f"Running HJSON configuration for example {i}")
            sys.argv = __generate_argv(
                example_number=i,
                config_dir=config_dir,
                pads_cfg=pads_cfg,
                output_dir=output_dir,
                template=template,
                extension="hjson",
            )
            mcu_gen.main()

            print(f"Example {i} processed")

    finally:
        # Restore original sys.argv
        sys.argv = original_argv


def main():
    """
    Run different configurations, compare the output of mcu_gen with an hjson config and a python config

    To add a new test :
    - Add a new config for every extension in existing_extensions in test/test_x_heep_gen/configs directory, all should yield the same peripheral configuration
    - Name both files example<number><extension>
    - Add the corresponding mcu_cfg<number>.hjson file in the same directory
    - Append the name of the test in test_names

    Current extension supported : .py and .hjson
    """

    test_names = []
    test_names.append("All peripherals included except PDM2PCM")
    test_names.append("No user peripheral")
    test_names.append("All user peripherals included")

    # Generate examples
    generate_examples(
        num_examples=len(test_names),
        config_dir="test/test_x_heep_gen/configs",
        pads_cfg="pad_cfg.hjson",
        output_dir="test/test_x_heep_gen/outputs",
        template="test/test_x_heep_gen/template.hjson.tpl",
    )

    test_results = []

    # Run examples
    for i in range(1, len(test_names) + 1):
        test_results.append(run_test(i, test_names[i - 1]))

    if not all(test_results):
        exit(1)  # Exit with error if any test failed


if __name__ == "__main__":
    main()
